# Form implementation generated from reading ui file 'GraphWindow.ui'
#
# Created by: PyQt6 UI code generator 6.4.2
#
# WARNING: Any manual changes made to this file will be lost when pyuic6 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt6 import QtCore, QtGui, QtWidgets
import pyqtgraph as pg
import numpy as np
import sys
import time

import HelpWindow
import elemoperations

color = [QtGui.QColor(255, 0, 0, 50), QtGui.QColor(255, 255, 0, 50), QtGui.QColor(255, 0, 255, 50),
         QtGui.QColor(0, 255, 0),
         QtGui.QColor(0, 255, 255, 50), QtGui.QColor(0, 0, 255), QtGui.QColor(255, 255, 255)]


class Ui_DrawPattern(object):
    def __init__(self, path, ans, options, bounds):
        super().__init__()
        self.styles = {0: QtCore.Qt.BrushStyle.SolidPattern, 1: QtCore.Qt.BrushStyle.Dense1Pattern,
                       2: QtCore.Qt.BrushStyle.Dense2Pattern, 3: QtCore.Qt.BrushStyle.Dense3Pattern,
                       4: QtCore.Qt.BrushStyle.Dense4Pattern, 5: QtCore.Qt.BrushStyle.Dense5Pattern,
                       6: QtCore.Qt.BrushStyle.Dense6Pattern, 7: QtCore.Qt.BrushStyle.Dense7Pattern,
                       8: QtCore.Qt.BrushStyle.BDiagPattern, 9: QtCore.Qt.BrushStyle.FDiagPattern,
                       10: QtCore.Qt.BrushStyle.DiagCrossPattern}

        self.ans = ans

        self.x_bars = []
        self.y_bars = []
        self.saved_x_bars = []
        self.saved_y_bars = []
        self.expressions = []
        self.options = options
        self.bounds = bounds
        self.squares = []
        self.squares_text = ""
        # print("BOUNDS", bounds)
        self.bounds_square = (self.bounds[2] - self.bounds[0]) * (self.bounds[-1] - self.bounds[1])
        if len(bounds) != 0:
            self.bounds = bounds + bounds[0:2]

        self.elem_cell_visible = []
        self.whole_cell_visible = []

        self.path = path

        self.start_time = 0

        self.coords_text = pg.TextItem()

        self.vLine = pg.InfiniteLine(angle=90, movable=False)
        self.hLine = pg.InfiniteLine(angle=0, movable=False)
        self.xvLine = pg.InfiniteLine(angle=90, movable=False)
        self.xhLine = pg.InfiniteLine(angle=0, movable=False)
        self.yvLine = pg.InfiniteLine(angle=90, movable=False)
        self.yhLine = pg.InfiniteLine(angle=0, movable=False)

        self.legend = pg.LegendItem((60, 60), offset=(20, 20))

        self.cell_min_x = 100000000
        self.cell_max_x = -100000000
        self.cell_min_y = 100000000
        self.cell_max_y = -100000000

    def setupUi(self, DrawPattern):
        DrawPattern.setObjectName("DrawPattern")
        DrawPattern.resize(711, 581)
        self.gridLayout = QtWidgets.QGridLayout(DrawPattern)
        self.gridLayout.setObjectName("gridLayout")

        self.YGraph = pg.GraphicsLayoutWidget(parent=DrawPattern)
        self.YGraph.setBackgroundBrush(QtGui.QBrush(self.options[0]))
        self.YGraph.setMaximumSize(QtCore.QSize(150, 16777215))
        self.YGraph.setObjectName("YGraph")
        self.gridLayout.addWidget(self.YGraph, 0, 0, 1, 1)
        self.y_plt = self.YGraph.addPlot(name='y', lockAspect=True)
        self.y_plt.addItem(self.yhLine, ignoreBounds=True)
        self.y_plt.addItem(self.yvLine, ignoreBounds=True)

        self.verticalScrollBar = QtWidgets.QScrollBar(parent=DrawPattern)
        self.verticalScrollBar.setOrientation(QtCore.Qt.Orientation.Vertical)
        self.verticalScrollBar.setObjectName("verticalScrollBar")
        self.gridLayout.addWidget(self.verticalScrollBar, 0, 1, 1, 1)
        self.horizontalScrollBar = QtWidgets.QScrollBar(parent=DrawPattern)
        self.horizontalScrollBar.setOrientation(QtCore.Qt.Orientation.Horizontal)
        self.horizontalScrollBar.setObjectName("horizontalScrollBar")
        self.gridLayout.addWidget(self.horizontalScrollBar, 1, 2, 1, 1)

        self.Cell = pg.GraphicsLayoutWidget(parent=DrawPattern)
        self.Cell.setBackgroundBrush(QtGui.QBrush(self.options[0]))
        self.Cell.setObjectName("Cell")
        self.gridLayout.addWidget(self.Cell, 0, 2, 1, 1)
        self.cell_plt = self.Cell.addPlot(name='cell')
        self.cell_plt.setAspectLocked(True)
        self.cell_plt.showAxis('left', False)
        self.cell_plt.showAxis('bottom', False)
        self.cell_plt.addItem(self.vLine, ignoreBounds=True)
        self.cell_plt.addItem(self.hLine, ignoreBounds=True)
        self.legend.setParentItem(self.cell_plt.graphicsItem())

        self.XGraph = pg.GraphicsLayoutWidget(parent=DrawPattern)
        self.XGraph.setBackgroundBrush(QtGui.QBrush(self.options[0]))
        self.XGraph.setMaximumSize(QtCore.QSize(16777215, 150))
        self.XGraph.setObjectName("XGraph")
        self.gridLayout.addWidget(self.XGraph, 2, 2, 1, 1)
        self.x_plt = self.XGraph.addPlot(name='x', lockAspect=True)
        self.x_plt.addItem(self.xvLine, ignoreBounds=True)
        self.x_plt.addItem(self.xhLine, ignoreBounds=True)

        self.cell_plt.setYLink('y')
        self.cell_plt.setXLink('x')
        self.x_plt.setXLink('cell')
        self.y_plt.setYLink('cell')

        self.ToolBarWidget = QtWidgets.QWidget(parent=DrawPattern)
        self.ToolBarWidget.setObjectName("ToolBarWidget")
        self.gridLayout_2 = QtWidgets.QGridLayout(self.ToolBarWidget)
        self.gridLayout_2.setObjectName("gridLayout_2")
        self.oneStepLeft = QtWidgets.QToolButton(parent=self.ToolBarWidget)
        self.oneStepLeft.setObjectName("oneStepLeft")
        self.gridLayout_2.addWidget(self.oneStepLeft, 1, 0, 1, 1)
        self.label_item = QtWidgets.QPlainTextEdit(parent=self.ToolBarWidget)
        self.label_item.setLineWrapMode(QtWidgets.QPlainTextEdit.LineWrapMode.NoWrap)
        self.label_item.setObjectName("label_item")
        self.gridLayout_2.addWidget(self.label_item, 3, 0, 1, 4)
        self.oneStepRight = QtWidgets.QToolButton(parent=self.ToolBarWidget)
        self.oneStepRight.setObjectName("oneStepRight")
        self.gridLayout_2.addWidget(self.oneStepRight, 1, 3, 1, 1)

        self.stepSlider = QtWidgets.QSlider(parent=self.ToolBarWidget)
        self.stepSlider.setOrientation(QtCore.Qt.Orientation.Horizontal)
        self.stepSlider.setObjectName("stepSlider")
        self.stepSlider.setMinimum(1)

        self.gridLayout_2.addWidget(self.stepSlider, 1, 1, 1, 2)
        self.gridLayout.addWidget(self.ToolBarWidget, 1, 0, 2, 2)

        self.stepSlider.valueChanged[int].connect(lambda: self.slider_update(self.stepSlider.value()))
        self.oneStepLeft.clicked.connect(lambda: self.stepSlider.setValue(self.stepSlider.value() - 1))
        self.oneStepRight.clicked.connect(lambda: self.stepSlider.setValue(self.stepSlider.value() + 1))

        self.retranslateUi(DrawPattern)
        QtCore.QMetaObject.connectSlotsByName(DrawPattern)

    def retranslateUi(self, DrawPattern):
        _translate = QtCore.QCoreApplication.translate
        DrawPattern.setWindowTitle(_translate("DrawPattern", "Form"))
        self.oneStepLeft.setText(_translate("DrawPattern", "<"))
        self.oneStepRight.setText(_translate("DrawPattern", ">"))

    # Удалить скроллбары
    # _____________________________________________________________
    def whole_cell_plot(self):
        # element_fill_style = {"NA": 1}
        with open(self.path, "r") as file:
            for line in file:
                if line[0] == "L":
                    pen = QtGui.QPen(QtGui.QColor(255, 255, 255, 0), 5)
                    brush = QtGui.QBrush(QtGui.QColor(0, 0, 0, 0))
                    for elem in self.options[1]:
                        if elem[0] == line[2:line.find(';')] or elem[0] == "С" + line[3:line.find(';')]:
                            # L = elem[0]
                            pen = QtGui.QPen(QtGui.QColor(elem[1].red(), elem[1].green(), elem[1].blue(), 200), elem[2])
                            brush = QtGui.QBrush(QtGui.QColor(elem[3].red(), elem[3].green(), elem[3].blue(), elem[4]))
                            brush.setStyle(self.styles[elem[5]])
                elif line[0] == "P":
                    x_list = []
                    y_list = []
                    switch = True
                    # x_list.append(int(line[2:line[2:].find(" ") + 3]))
                    coord = ""
                    i = 2
                    while line[i] != ';':
                        if line[i] != " ":
                            coord = coord + line[i]
                        else:
                            if switch:
                                x_list.append(int(coord))
                            else:
                                y_list.append(int(coord))
                            switch = not switch
                            coord = ""
                        i += 1
                    y_list.append(int(coord))
                    x_list.append(x_list[0])
                    y_list.append(y_list[0])

                    local_min_x = min(x_list)
                    local_max_x = max(x_list)
                    local_min_y = min(y_list)
                    local_max_y = max(y_list)

                    if local_max_x > self.cell_max_x: self.cell_max_x = local_max_x
                    if local_min_x < self.cell_min_x: self.cell_min_x = local_min_x
                    if local_max_y > self.cell_max_y: self.cell_max_y = local_max_y
                    if local_min_y < self.cell_min_y: self.cell_min_y = local_min_y

                    elementQPath = pg.arrayToQPath(np.array(x_list), np.array(y_list))
                    elementPathItem = QtWidgets.QGraphicsPathItem(elementQPath)
                    elementPathItem.setBrush(brush)
                    elementPathItem.setPen(pen)
                    self.cell_plt.addItem(elementPathItem, hoverable=True)

        if len(self.bounds) != 0:
            pen = QtGui.QPen(QtGui.QColor(128, 128, 128, 50), 10)
            brush = QtGui.QBrush(QtGui.QColor(0, 0, 0, 0))
            elementQPath = pg.arrayToQPath(np.array(self.bounds[0::2]), np.array(self.bounds[1::2]))
            elementPathItem = QtWidgets.QGraphicsPathItem(elementQPath)
            elementPathItem.setBrush(brush)
            elementPathItem.setPen(pen)
            self.cell_plt.addItem(elementPathItem, hoverable=True)

    def data_processer(self, expression):
        expression_for_cell = []
        expression_list = []
        last_points = []
        # print("expr", expression)
        if type(expression[0]) == list:
            for i in range(len(expression)):
                if expression[i][0] != None:
                    expression_list += expression[i]
                    expression[i].append(expression[i][0])
                    expression[i].append(expression[i][1])

                    last_points.append(expression[i][0])
                    last_points.append(expression[i][1])
                    expression_for_cell += expression[i]

            expression_for_cell.append(expression_for_cell[0])
            expression_for_cell.append(expression_for_cell[1])

            for item in last_points:
                expression_for_cell.append(item)

        else:
            expression_list = expression
            expression_for_cell = expression
            expression_for_cell.append(expression_for_cell[0])
            expression_for_cell.append(expression_for_cell[1])
        # print("lp", last_points)
        # print("exp_4_cell", expression_for_cell)
        return [expression_for_cell, expression_list]

    def expression_plot(self, expression, i):
        self.expressions.append([])
        # print("exp", expression)

        # print("sp", self.options)
        j = 0
        # for elem in expression:
        # print("expr elem: ", elem)
        expressionQPath = pg.arrayToQPath(np.array(expression[0::2]), np.array(expression[1::2]))
        expressionPathItem = QtWidgets.QGraphicsPathItem(expressionQPath)
        pen = QtGui.QPen(QtGui.QColor(0, 0, 0, 0))
        options = [255, 0, 0, 0, 0, 255, 0, 255, 0]
        # j += 1
        # if j < 4:
        brush = QtGui.QBrush(QtGui.QColor(self.options[i + 2][0].red(), self.options[i + 2][0].green(),
                                            self.options[i + 2][0].blue(), self.options[i + 2][1]))
            # else:
                # brush = QtGui.QBrush(QtGui.QColor(options[1], options[1],
                                                  # options[0], 200))
                # j += 1
        brush.setStyle(self.styles[self.options[i + 2][2]])
        expressionPathItem.setPen(pen)
        expressionPathItem.setBrush(brush)

        self.cell_plt.addItem(expressionPathItem)

        self.expressions[i].append(expressionPathItem)

    def x_y_graphs_plot(self, expression, count):
        x_arr = np.zeros(self.cell_max_x - self.cell_min_x)
        y_arr = np.zeros(self.cell_max_y - self.cell_min_y)

        x_arr_switch = np.zeros((self.cell_max_x - self.cell_min_x), dtype=np.bool_)
        y_arr_switch = np.zeros((self.cell_max_y - self.cell_min_y), dtype=np.bool_)

        points_list = []
        # print(expression)
        
        for i in range(0, len(expression) - 1, 2):
            points_list.append([expression[i], expression[i + 1]])
        points_list = elemoperations.delete_repeating_points(points_list)
        sublists = elemoperations.sublist_form(points_list)
        # x
        for i in range(0, len(sublists[1])):
            for j in range(0, len(sublists[1][i]) - 1, 2):
                left_pointer = sublists[1][i][j][0] - self.cell_min_x
                right_pointer = sublists[1][i][j + 1][0] - self.cell_min_x
                for k in range(left_pointer, right_pointer):
                    if x_arr_switch[k]:
                        x_arr[k] += sublists[1][i][j][1]
                    else:
                        x_arr[k] -= sublists[1][i][j][1]
                    x_arr_switch[k] = not x_arr_switch[k]
        # y
        for i in range(0, len(sublists[0])):
            for j in range(0, len(sublists[0][i]) - 1, 2):
                left_pointer = sublists[0][i][j][1] - self.cell_min_y
                right_pointer = sublists[0][i][j + 1][1] - self.cell_min_y
                for k in range(left_pointer, right_pointer):
                    if y_arr_switch[k]:
                        y_arr[k] += sublists[0][i][j][0]
                    else:
                        y_arr[k] -= sublists[0][i][j][0]
                    y_arr_switch[k] = not y_arr_switch[k]

        bar_y = pg.BarGraphItem(x0=0, height=1,
                                y=np.arange(self.cell_min_y + 0.5, self.cell_max_y + 0.5, 1), width=y_arr,
                                brush=(self.options[count + 2][0].red(), self.options[count + 2][0].green(),
                                       self.options[count + 2][0].blue(), self.options[count + 2][1]),
                                pen=(0, 0, 0, 0))
        self.y_plt.addItem(bar_y)
        self.legend.addItem(bar_y, str(count))

        bar_x = pg.BarGraphItem(x=np.arange(self.cell_min_x + 0.5, self.cell_max_x + 0.5), height=x_arr, width=1,
                                brush=(self.options[count + 2][0].red(), self.options[count + 2][0].green(),
                                       self.options[count + 2][0].blue(), self.options[count + 2][1]),
                                pen=(0, 0, 0, 0))
        self.x_plt.addItem(bar_x)
        self.x_bars.append(bar_x)
        self.y_bars.append(bar_y)
        self.saved_x_bars.append(bar_x)
        self.saved_y_bars.append(bar_y)

        square = 0
        for num in y_arr:
            square += num

        return square

    def slider_update(self, value):

        self.y_plt.clear()
        self.x_plt.clear()
        self.legend.clear()
        for i in range(len(self.ans)):
            height_x = self.saved_x_bars[i].getData()[1]
            width_x = self.saved_x_bars[i].getData()[0]
            height_y = self.saved_y_bars[i].opts.get('width')
            width_y = self.saved_y_bars[i].opts.get('y')

            if value != 1:
                len_x = np.prod(height_x.shape).item()
                len_y = np.prod(height_y.shape).item()

                new_height_x = np.zeros(len_x)
                new_height_y = np.zeros(len_y)

                j = 0
                while j < len_x - 1:
                    k = j
                    sum_heights_x = 0
                    while k < j + value and k != len_x - 1:
                        sum_heights_x += height_x[k]
                        k += 1
                    l = j
                    while l < j + value and l != len_x - 1:
                        new_height_x[l] = sum_heights_x / min(value, len_x - j)
                        l += 1
                    j += value

                j = 0
                while j < len_y - 1:
                    k = j
                    sum_heights_y = 0
                    while k < j + value and k != len_y - 1:
                        sum_heights_y += height_y[k]
                        k += 1
                    l = j
                    while l < j + value and l != len_y - 1:
                        new_height_y[l] = sum_heights_y / min(value, len_y - j)
                        l += 1
                    j += value

                bar_y = pg.BarGraphItem(x0=0, height=1,
                                        y=width_y, width=new_height_y,
                                        brush=(self.options[i + 2][0].red(), self.options[i + 2][0].green(),
                                               self.options[i + 2][0].blue(), self.options[i + 2][1]),
                                        pen=(0, 0, 0, 0))
                self.y_plt.addItem(bar_y)

                bar_x = pg.BarGraphItem(x=width_x, height=new_height_x, width=1,
                                        brush=(self.options[i + 2][0].red(), self.options[i + 2][0].green(),
                                               self.options[i + 2][0].blue(), self.options[i + 2][1]),
                                        pen=(0, 0, 0, 0))
                self.x_plt.addItem(bar_x)

                self.x_bars.pop(0)
                self.y_bars.pop(0)
                self.x_bars.append(bar_x)
                self.y_bars.append(bar_y)
                self.legend.addItem(bar_y, str(i))
            else:
                bar_y = pg.BarGraphItem(x0=0, height=1,
                                        y=width_y, width=height_y,
                                        brush=(self.options[i + 2][0].red(), self.options[i + 2][0].green(),
                                               self.options[i + 2][0].blue(), self.options[i + 2][1]),
                                        pen=(0, 0, 0, 0))
                self.y_plt.addItem(bar_y)

                bar_x = pg.BarGraphItem(x=width_x, height=height_x, width=1,
                                        brush=(self.options[i + 2][0].red(), self.options[i + 2][0].green(),
                                               self.options[i + 2][0].blue(), self.options[i + 2][1]),
                                        pen=(0, 0, 0, 0))
                self.x_plt.addItem(bar_x)
                self.x_bars.pop(0)
                self.y_bars.pop(0)
                self.x_bars.append(bar_x)
                self.y_bars.append(bar_y)
                self.legend.addItem(bar_y, str(i))
        self.y_plt.addItem(self.yhLine, ignoreBounds=True)
        self.y_plt.addItem(self.yvLine, ignoreBounds=True)
        self.x_plt.addItem(self.xhLine, ignoreBounds=True)
        self.x_plt.addItem(self.xvLine, ignoreBounds=True)
        self.label_item.setPlainText("step=" + str(value) + "\n")

    def screen(self):
        self.whole_cell_plot()
        for i in range(len(self.ans)):
            expression = self.data_processer(self.ans[i])
            self.expression_plot(expression[0], i)
            self.squares.append(self.x_y_graphs_plot(expression[1], i))
        self.stepSlider.setMaximum(min(self.cell_max_x, self.cell_max_y))

        for i in range(len(self.squares)):
            self.squares_text += "\n" + str(i) + ": " +  str(round(self.squares[i] / self.bounds_square * 100, 3)) + "%"
        vb_cell = self.cell_plt.vb
        vb_x = self.x_plt.vb
        vb_y = self.y_plt.vb

        def mouseClicked(ev):
            end_time = time.time()
            if end_time - self.start_time < 0.5:
                self.w = AnotherWindow(self.y_bars, self.options)
                #self.w.show()

            self.start_time = time.time()
            for i in range(0, len(self.y_bars)):
                # print(self.expressions[i])
                if not self.y_bars[i].isVisible():
                    self.x_bars[i].hide()
                    for j in range(len(self.expressions[i])):
                        self.expressions[i][j].hide()
                else:
                    self.x_bars[i].show()
                    for j in range(len(self.expressions[i])):
                        self.expressions[i][j].show()
            """for j in range(0, len(self.elem_cell_visible)):
                if not self.elem_cell_visible[i].isVisible():
                    self.whole_cell_visible[i].hide()
                else:
                    self.whole_cell_visible[i].show()"""

        def cell_mouse_moved(evt):
            pos = evt
            if self.cell_plt.sceneBoundingRect().contains(pos):
                mousePoint = vb_cell.mapSceneToView(pos)

                self.label_item.setPlainText(str("step=" + str(self.stepSlider.value()) + "\n" \
                                            + "x=" + str(int(mousePoint.x())) + "y=" + str(int(mousePoint.y())) +
                                            self.squares_text))

                self.hLine.setVisible(True)
                self.vLine.setVisible(True)
                self.yhLine.setVisible(True)
                self.xvLine.setVisible(True)
                self.yvLine.setVisible(False)
                self.xhLine.setVisible(False)

                self.vLine.setPos(mousePoint.x())
                self.hLine.setPos(mousePoint.y())
                self.xvLine.setPos(mousePoint.x())
                self.yhLine.setPos(mousePoint.y())
            else:
                self.label_item.setPlainText(str("step=" + str(self.stepSlider.value()) + self.squares_text))

        def x_mouse_moved(evt):
            pos = evt
            if self.x_plt.sceneBoundingRect().contains(pos):
                mousePoint = vb_x.mapSceneToView(pos)

                self.label_item.setPlainText(str("step=" + str(self.stepSlider.value()) + "\n"\
                                            + "x=" + str(int(mousePoint.x())) + "y=" + str(int(mousePoint.y())) +
                                            self.squares_text))

                self.vLine.setVisible(True)
                self.xhLine.setVisible(True)
                self.xvLine.setVisible(True)
                self.yhLine.setVisible(False)
                self.hLine.setVisible(False)
                self.yvLine.setVisible(False)

                self.xvLine.setPos(mousePoint.x())
                self.xhLine.setPos(mousePoint.y())
                self.vLine.setPos(mousePoint.x())
            else:
                self.label_item.setPlainText(str("step=" + str(self.stepSlider.value()) + self.squares_text))

        def y_mouse_moved(evt):
            pos = evt
            if self.y_plt.sceneBoundingRect().contains(pos):
                mousePoint = vb_y.mapSceneToView(pos)

                self.label_item.setPlainText(str("step=" + str(self.stepSlider.value()) + "\n" \
                                            + "x=" + str(int(mousePoint.x())) + "y=" + str(int(mousePoint.y())) +
                                            self.squares_text))

                self.hLine.setVisible(True)
                self.yhLine.setVisible(True)
                self.yvLine.setVisible(True)
                self.vLine.setVisible(False)
                self.xhLine.setVisible(False)
                self.xvLine.setVisible(False)

                self.yvLine.setPos(mousePoint.x())
                self.yhLine.setPos(mousePoint.y())
                self.hLine.setPos(mousePoint.y())
            else:
                self.label_item.setPlainText(str("step=" + str(self.stepSlider.value()) + self.squares_text))
        self.cell_plt.scene().sigMouseMoved.connect(cell_mouse_moved)
        self.x_plt.scene().sigMouseMoved.connect(x_mouse_moved)
        self.y_plt.scene().sigMouseMoved.connect(y_mouse_moved)
        self.cell_plt.scene().sigMouseClicked.connect(mouseClicked)



class AnotherWindow(QtWidgets.QWidget):

    def __init__(self, bar, opts):
        super().__init__()
        self.gridLayout = QtWidgets.QGridLayout()
        self.gridLayout.setObjectName("gridLayout")
        self.setLayout(self.gridLayout)

        self.YGraph = pg.GraphicsLayoutWidget()
        self.YGraph.setBackgroundBrush(QtGui.QBrush(opts[0]))
        self.YGraph.setObjectName("YGraph")
        self.gridLayout.addWidget(self.YGraph, 0, 0, 1, 1)

        plt = self.YGraph.addPlot()
        plt.addItem(bar[0])

        # Ui_DrawPattern.y_plt.addItem(self.yhLine, ignoreBounds=True)
        # Ui_DrawPattern.y_plt.addItem(self.yvLine, ignoreBounds=True)

        layout = QtWidgets.QVBoxLayout()
        self.label = QtWidgets.QLabel("Another Window % d")
        layout.addWidget(self.label)
        self.setLayout(layout)

        # activefill(можно ли вообще)
        # несколько графиков с вкл/выкл видимость
        # убрать page
        # доставать вкладки
